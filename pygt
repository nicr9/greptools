#! /usr/bin/python2.7
import sys
import re
import subprocess
import json
from argparse import ArgumentParser, RawTextHelpFormatter

class Publisher(object):
    # Constants
    LINES = 'lines'

    # Templates
    CONTEXT_COLOUR = "\033[93m%s\033[0m"
    LINE_SUM_COLOUR = "\033[91m%d:^\033[0m%s\033[91m$\033[0m"
    CONTEXT_CLEAN = "%s"
    LINE_SUM_CLEAN = "%d:^%s$"

    # Template dicts
    VALID_FORMATS = [
            'colour',
            'clean'
            ]
    LINE_SUM_TEMPS = {
            'colour': LINE_SUM_COLOUR,
            'clean': LINE_SUM_CLEAN
            }
    CONTEXT_TEMPS = {
            'colour': CONTEXT_COLOUR,
            'clean': CONTEXT_CLEAN
            }

    def __init__(self, config):
        self.set_format(config.outp_format)
        self.debug = config.debug

    def set_format(self, outp_format):
        assert outp_format in self.VALID_FORMATS

        self.line_sum_template = self.LINE_SUM_TEMPS[outp_format]
        self.context_template = self.CONTEXT_TEMPS[outp_format]

    def _format_line(self, line_number, line_text):
        return self.line_sum_template % (line_number, line_text)

    def print_dict(self, obj, counter=0):
        for key, val in obj.iteritems():
            if isinstance(val, dict):
                print ' '*counter + self.context_template % key
                if self.LINES in val:
                    for line_num, line_txt in val[self.LINES]:
                        processed_row = self._format_line(line_num, line_txt)
                        print ' '*(counter+4), processed_row
                    print
                self.print_dict(val, counter+4)
            elif isinstance(val, list):
                pass
            elif isinstance(val, str):
                print ' '*counter, val
            else:
                print "%s type found: %s" % (type(val), val)

        if self.debug and counter == 0:
            #print "Total found: %d" % self._num_found
            raise Exception(
                    'This functionality has been disabled during refactoring'
                    )

class Context(object):
    # CONSTANTS
    INDENT_RE = re.compile("^(\s*)")
    DEF_CLASS_RE = re.compile("^\s*(def|class) (.*?)[(:]")
    TAB = '\t'
    FOUR_SPACES = '    '
    GREP_TEMPLATE = 'grep ./ -Irne "%s" --include="*.py"'
    LINES = 'lines'

    # VARIABLES
    context = {}

    def __init__(self, config):
        self.outp_path = config.outp_path
        self.debug = config.debug
        self.filter_regex = config.filter_regex
        self._num_found = 0

    @classmethod
    def from_file(cls, config):
        temp = cls(config)
        temp.context = cls.load(config.inp_path)

        return temp

    @classmethod
    def from_grep(cls, config):
        temp = cls(config)
        temp.grep_for(config.search_term)

        return temp

    @staticmethod
    def load(path):
        with open(path, 'r') as inp_file:
            return json.load(inp_file)

    def dump(self):
        with open(self.outp_path, 'w') as outp_file:
            flat = json.dumps(self.context, indent=4)
            outp_file.write(flat)

    def perform_union(self, path):
        pass

    def perform_join(self, path):
        pass

    def append(self, file_path, line_number, line_text, cntx_list):
        """
        Adds a line to the context tree.
        """
        # Step through context tree, creating nodes along the way
        pointer = self.context[file_path]
        for step in cntx_list:
            if step not in pointer:
                pointer[step] = {}
            pointer = pointer[step]
        if self.LINES not in pointer:
            pointer[self.LINES] = []

        # Add line_number + line_text to context
        pointer[self.LINES].append((line_number, line_text))
        self._num_found += 1

    def _get_indent(self, line):
        """
        Returns the indentation on a line as a substring.
        """
        match = re.match(self.INDENT_RE, line)
        indent = match.group(1)

        return re.sub(self.TAB, self.FOUR_SPACES, indent)

    def get_context(self, file_path, file_line):
        """
        Given the file path and the line number, determine the context of that line.
        """
        file_indx = file_line - 1

        # Add file path node to context
        if not file_path in self.context:
            self.context[file_path] = {}

        # Read in all lines up to and including the line given
        lines = []
        with open(file_path) as file_:
            for i, line in enumerate(file_):
                if i <= file_indx:
                    lines.append(line)
                else:
                    break
        assert len(lines) == file_line

        # Get indent of specified line
        init_indent = self._get_indent(lines[file_indx])

        results = []
        for line_no in range(file_indx-1, -1, -1):
            # Ignore empty lines
            if lines[line_no].strip():
                # Ignore lines that aren't a function or a class
                kw_match = re.search(self.DEF_CLASS_RE, lines[line_no])
                if kw_match:
                    # Get indent of relevant lines
                    next_indent = self._get_indent(lines[line_no])

                    # if line has less indentation add to results
                    # then change init_indent
                    if len(next_indent) < len(init_indent):
                        results.append(
                            ' '.join(kw_match.groups())
                            )
                        init_indent = next_indent

        # Add this entry to context tree
        self.append(
                file_path,
                file_line,
                lines[file_indx].strip('\n'),
                reversed(results)
                )

    def grep_for(self, exp):
        """
        Execute a grep command to search for the given expression.
        Then print out the context for each result.
        """
        results = []
        try:
            response = subprocess.check_output(
                    [self.GREP_TEMPLATE % exp],
                    shell=True
                    )
            results = response.splitlines()

            if self.debug:
                print "=== Grep results ==="
                print response, "Total results: %d\n" % len(results)
        except subprocess.CalledProcessError, e:
            if e.returncode == 1:
                print "Couldn't find anything matching '%s'" % exp
            else:
                print "Whoops, grep returned errorcode %d" % e.errorcode
            sys.exit()

        for row in results:
            file_name, file_line, line_text = row.split(':')[:3]

            if self.filter_regex and not re.search(self.filter_regex, line_text):
                continue

            self.get_context(file_name, int(file_line))

class GrepTools(object):
    # CONSTANTS
    DESCRIPTION = 'Python Grep Tool.'
    EPILOG = 'Author: Nic Roland\nEmail: nicroland9@gmail.com\nTwitter: @nicr9_'

    def __init__(self, args):
        config = self.parse_args(args)

        if config.debug:
            print "=== CLI args ==="
            print args, '\n'
            config_pretty = {x:y for x, y in config._get_kwargs()}
            print "=== pygt config ==="
            print json.dumps(config_pretty, indent=4) + '\n'

        # Either load results or grep new ones
        if config.inp_path:
            context = Context.from_file(config)
        else:
            context = Context.from_grep(config)

        ## Set operations
        #if config.union:
        #    self.perform_union(config.union)
        #elif config.join:
        #    self.perform_join(config.join)

        if config.debug:
            print "=== Results dict ==="
            print json.dumps(context.context, indent=4) + '\n'

        # Save to file or configure outp formatting
        if config.outp_path:
            context.dump()
        else:
            publisher = Publisher(config)
            publisher.print_dict(context.context)

    def _arg_desc_list(self, inp):
        return '\n' + '\n'.join(['- ' + z for z in inp])

    def parse_args(self, argv):
        parser = ArgumentParser(
                formatter_class = RawTextHelpFormatter,
                description = self.DESCRIPTION,
                epilog = self.EPILOG
                )

        parser.add_argument(
                'search_term',
                default = None,
                nargs='?',
                type = str,
                help = 'Regex to search for'
                )

        parser.add_argument(
                '-f',
                '--format',
                default = 'colour',
                type = str,
                help = 'Format to display output in:%s' 
                        % self._arg_desc_list(Publisher.VALID_FORMATS),
                dest = 'outp_format'
                )

        parser.add_argument(
                '-o',
                '--outp',
                type = str,
                help = 'Save results to file',
                dest = 'outp_path',
                default = None
                )

        parser.add_argument(
                '-i',
                '--inp',
                type = str,
                help = 'Load results from file',
                dest = 'inp_path',
                default = None
                )

        parser.add_argument(
                '-F',
                help = "Filter resultng lines by regex",
                dest = 'filter_regex',
                default = None
                )

        #parser.add_argument(
        #        '-U',
        #        help = "Perform a union with the results in file.",
        #        dest = 'union',
        #        default = None
        #        )

        #parser.add_argument(
        #        '-J',
        #        help = "Perform a join with the results in file.",
        #        dest = 'join',
        #        default = None
        #        )

        parser.add_argument(
                '-d',
                action = 'store_true',
                help = "Display additional information to aid debugging.",
                dest = 'debug'
                )

        return parser.parse_args(argv[1:])

if __name__ == "__main__":
    GrepTools(sys.argv)
